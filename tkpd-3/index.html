<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script 
		src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js">
	</script>
	<script src="./js/three.js"></script>
	<script src="./js/ColladaLoader.js"></script>
	<script src="./js/CombinedCamera.js"></script>

	<script src="./js/Projector.js"></script>
	<script src="./js/CanvasRenderer.js"></script>

</head>
<body>
	<div id="theDiv"></div>
	<script>
		var camera, renderer, loader, container;
		var cubeMesh;
		var dae;

		init();
		render();

		function init() {

			//init dom container
			container = document.createElement( 'div' );
			document.body.appendChild( container );

			//init renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xdddddd);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container.appendChild( renderer.domElement );
			// $('#theDiv').add(renderer.domElement);
			
			//init scene
			scene = new THREE.Scene();

			//init camera
			camera = new THREE.CombinedCamera(window.innerWidth / 2, window.innerHeight / 2, 1, 1, 1000, 1, 5000);

			camera.position.x = 5;
			camera.position.y = 5;
			camera.position.z = -10;

			camera.toOrthographic();
			camera.setZoom(2);

			//init grid
			var size = 10;
			var divisions = 10;

			var gridHelper = new THREE.GridHelper( size, divisions );
			scene.add( gridHelper );
			
			

			//init cube
			// var geometry = new THREE.BoxGeometry( 1, 1, 1 );
			// var material = new THREE.MeshLambertMaterial( { color: 0xffffff, overdraw: 0.5 } );
			// cubeMesh = new THREE.Mesh(geometry, material);
			// scene.add(cubeMesh);

			

			//init models
			loader = new THREE.ObjectLoader();
			// loader.options.convertUpAxis = true;
			loader.load('./models/tkpd-main.json', function(obj){
				// console.log(obj);
				// console.log(mat);
				// obj.mergeVertices()
				// obj.computeVertexNormals();
				// var matts = new THREE.MeshPhongMaterial({color:0xff0000, shininess: 100, specular: '#a9fcff', overdraw: 1});
				// matts.shading = THREE.SmoothShading;
				// var mm = new THREE.Mesh(obj, matts);
				// mm.position.x = mm.position.y = mm.position.z = 0;
				// scene.add(mm);
				var owlMaterials = new THREE.MultiMaterial( materials );

				obj.traverse(function(child){
					console.log(child.material);
					if(obj.name == 'Owl') {
						obj.material = owlMaterials;
					}
				});


				
				// scene.add(obj);
			});

			

			loader = new THREE.JSONLoader();
			loader.setTexturePath('./models');
			loader.load('./models/owl-only.json', function(obj, mats){
				obj.computeVertexNormals();
				// obj.computeTangents();
				// obj.mergeVertices();
				var materials = [

						//EyeSocket
					    new THREE.MeshPhongMaterial({ 
					    	color: 592137,
					    	specular: 8355711,
					    	shininess: 100, 
				    	}),
				    	//tkpd-green
					    new THREE.MeshPhongMaterial({ 
					    	color: 881936,
					    	specular: 8355711,
					    	shininess: 100,
				    	}),
				    	//tkpd-darkgreen - side
					    new THREE.MeshPhongMaterial({ 
					    	color: '#1F5522',
					    	specular: 8355711,
					    	shininess: 100,
				    	}),
				    	//front
					    new THREE.MeshPhongMaterial({ 
					    	color: 881936,
					    	specular: 8355711,
					    	shininess: 100,
				    	}),
					    new THREE.MeshBasicMaterial( { color: 0x00ffff } ), // back
					    new THREE.MeshBasicMaterial( { color: 0x00ffff } ), // back
					    new THREE.MeshBasicMaterial( { color: 0x00ffff } ), // back

					];
				var owlMats = new THREE.MultiMaterial( materials ); 
				var owlMesh = new THREE.Mesh(obj, owlMats);
				owlMesh.rotation.y = (180 * Math.PI) / 180;
				scene.add(owlMesh);
			});

			//init lights
			var ambientLight = new THREE.AmbientLight(0xffffff, 1);
			scene.add( ambientLight );

			var pointLight = new THREE.PointLight(0xffffff, 0.5);
			pointLight.position.y = 5;
			scene.add(pointLight);

		}

		function render() {
			// cubeMesh.rotation.x += 0.1;
			requestAnimationFrame(render);
			camera.lookAt(scene.position);
			renderer.render( scene, camera );
		}


	</script>
</body>
</html>